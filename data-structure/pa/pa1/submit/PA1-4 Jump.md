# PA1-4 Jump

## 数据结构与算法

本题使用单调队列的数据结构，倒序推导时间，为了简单起见，队列中使用了数组而非链表。队列中储存各点的位置，根据该点到终点的最短时间升序排列。单调的具体实现方法是进队的时候新成员不断跟队尾成员比较耗时，若队尾成员耗时更长则直接删除，代码如下

```c++
void push(int t_index)
	{
		if (size() > 0)
		{
			while (minTime[data[right - 1]] >= minTime[t_index] && size() > 0)
			{
				right--;
			}
		}
		data[right] = t_index;
		right++;
	}
```

该算法的正确性由题目中区间的单调性保证，题目中有如下条件
$$
\begin{equation}  
\left\{  
             \begin{array}{**lr**}  
             i < l[i] ≤ r[i] ≤ n, &  \\  
             l[i] ≤ l[i + 1], & \\  
             r[i] ≤ r[i + 1] &    
             \end{array}  
\right.  
\end{equation}
$$
所以如果点A和点B均为计算过的点，点A在点B的后方，而且点B到终点的最短时间大于点A到终点的最短时间，则可以肯定点B对之后的计算没有作用，可以直接删除。出队计算的时候，如果该点大于r[i]也可以直接删除。

## 复杂度分析

使用一位数组实现队列，空间复杂度为$ O(n) $。时间复杂度方面，因为每个元素仅需入队/出队一次，所以总体复杂度为$ O(n) $，然而因为操作比较复杂，所以常数较大。

## 完成过程问题

显然，本题数据规模不支持普通的动态规划，我在咨询堵君懿小教员以后决定使用单调队列，最初入队代码如下

```c++
for (int j = l[i]; j < l[i+1]; j++)
		{
			queue.push(j);
		}
```



然而第一次提交以后有多个WA数据点，再次咨询以后发现是入队的顺序有问题。因为出队时要先出右边的点，所以入队的时候也应该右边的点先入队，而我刚开始是左边的点先入队。修改后如下

```c++
for (int j = l[i + 1] - 1; j >= l[i]; j--)
		{
			queue.push(j);
		}
```



然而还是有错误，参考微信群中flagger的说法，需要考虑相邻区间之间有空隙的情况，即$ r[i]<l[i+1] $，空隙中的元素不能入队。于是我进行了修改，入队的时候判断上界，最终入队代码如下

```c++
for (int j = min(l[i + 1] - 1,r[i]); j >= l[i]; j--)
		{
			queue.push(j);
		}
```

