# PA 3-2 Hacker

## 数据结构与算法

本题中使用的数据结构为散列，实现方式来自DSACPP的示例代码，为了适应题目要求进行了改动。本程序在处理字符串数据时将其全部转为19进制`long long`（每一位字符对应一位数字，为了方便操作反过来存，即在前面的字符对应着低位数字）。算法为先枚举长度小于等于5位的密码，将其加盐后对应的crc32存入散列，存入散列的函数进行了较大的修改，在`probe4Free`时，会判断当前位置的`key`是否相同，如果相同，则判断`value`是否也相同，若均相同则放弃插入，若`value`不相同则发生重复，将`value`置为-2并放弃插入。然后进行破解操作，对每个输入的crc32进行查找，根据返回值判断是何种情况，返回值为正说明查找成功且不重复，-1说明查找失败，-2说明查找的数据之前出现重复现象，已经置为无效。对每个有效的查找，将其首位加入`weekpassword`数组，然后尝试连续的弱口令加入散列。

## 复杂度分析

需要破解的密文数为$n$。理论上来说初始化的所有小于5位的密码与输入规模无关，为$O(1)$，但是通过理论计算可知，所有小于5位的密码约为$2 \times 10^6$个，大于本题中$n$的最大值，因此设其为$m$。同时本题中的密码有严格的长度限制($<=8$)，所以认为其长度$O(1)$空间复杂度方面，维护一个散列，散列的大小为$O(m+n)$（在本题中具体为$10^7$）。时间复杂度方面，得到某个字符串的crc32的复杂度为$O(1)$，散列插入、查找的期望复杂度$O(1)$（最坏情况复杂度$O(n+m)$，但是本题基本不会遇到最坏情况），那么初始化所有长度小于5的密文耗时$O(m)$，之后的破解耗时$O(n)$，总体为$O(m+n)$。

## 完成过程中的问题

我确定算法后较为顺利地实现了第一个版本并通过了九成测，但是时间和空间都卡得比较紧，我担心无法通过全部点。为了时空效率，我不得不对DSACPP的示例代码进行大改，舍弃了所有动态内存操作，全部使用静态数组，不进行任何的`new`与`delete`，时空效率有了明显的提高。
