# PA 3-4 Prefix

## 数据结构与算法

本题中除了数组以外未使用特殊的数据结构，本程序中的区间均为左闭右开。使用的算法如下：

kmp算法中需要事先计算next表，`next[i]`中储存满足是i后缀的最长前缀。通过next表，我们可以求出nextCount表，`nextCount[i]`表示是i后缀的所有前缀的数目。通过`next[i]`，找到所有满足条件前缀中的最长项j，其他满足条件的前缀应是此最长项的后缀，于是我们可以在求`next[j]`，不断迭代。用动态规划计算:

```c++
    nextCount[0] = 0;
    for (int i = 1; i <= strLen; i++)
    {
        nextCount[i] = nextCount[next[i]] + 1;
    }
```

所有出现的前缀一定以某个前缀串为后缀，因此将nextCount表中的所有项加起来即为答案。

## 复杂度分析

字符串长度为$n$。空间复杂度方面，next表、nextCount表均为$O(n)$，总体$O(n)$。时间复杂度方面 ，建立next表、建立nextCount表、最后求和计算输出结果用时均为$O(n)$，总体时间复杂度$O(n)$。

## 完成过程中的问题

本题完成过程中没有遇到太多的问题，就是修改了一下next表的上界，因为在kmp算法中如果完全匹配那么就无需查询next表，所以无需计算$next[n]$，然而本题中要计算所有前缀，需要计算该项。