# PA 3-6 sort

## 数据结构与算法

本程序使用的数据结构仅有数组和一个简单的`Data`结构，存储数组中的元素和它们来自哪个子列。

算法方面，采用的是四路归并排序，相比普通的（二路）归并，将要排序的数组平均分为四个部分，归并时同时对四个子列归并。归并时，先调用`test4way`对四个数组进行测试，先检查总共还剩几个未访问元素，如果小于四个，那么就是平凡情况，调用一次比较（或者只剩一个元素，根本无需调用）即可完成排序，如果大于四个，那么将找出所剩元素最多的子列（之一）与空子列（肯定只有一个，因为若是第一次测试，那么不会既有空子列元素数又大于等于4个，若是之后循环过程中访问完一个子列，那么会立即跳出循环进入测试，只有一个空子列），将最长子列的一半元素“移动”到空子列（改变指针与长度即可，无需复制）。

然后在保证所有子列不为空的情况下进行归并，归并时，我们使用4个`Data`元素表示四个子列的顶元素（第一个未访问的元素）。每次操作时，我们有前提：`iterData[1] < iterData[2]`（大小关系均指要排序的输入数列的大小顺序，下同），然后我们对`iterDatap[1],[3],[4]`进行三元比较，得到三者间的顺序`min, mid, max`，那么可以保证`min`是四者中的最小者，应该插入目标数组，并且将`min`对应的子列向后推进，而且我们有`mid < max`作为下一次操作的前提。如此循环，直至有子列为空时跳出，进行测试。

## 复杂度分析

空间复杂度方面，递归深度$O(logn)$，归并时需要拷贝前三部分保存，$O(n)$，总体$O(n)$。

时间复杂度方面，比较操作与`test4way`均为$O(1)$，根据递归递推式和Master Theorem
$$
T(n) = 4T(n/4) + O(n) = O(nlogn)
$$
那么渐进意义下时间复杂度为$O(nlogn)$。

为了说明该方法比二路归并更优（比较次数更少），我们计算常数。
$$
设二路归并时\ T(n) = k_1 nlogn，四路归并\  T(n) = k_2 nlogn\\
代入递推式，解得\\
k_1 = 1/log2 \qquad k_2=1/log4
$$
可见四路归并在常熟意义上优于二路归并。

## 完成过程中的问题

本题中我遇到的主要问题是当一个子列全部访问完毕以后怎么处理。刚开始我使用的方法是四路归并+三路归并+二路归并，然而在写完四路归并以后我感觉此种方法写法过于繁琐，而且在极端情况下（如顺序数列），可能访问一个子列后其他子列都没有访问，发生退化。于是我在咨询同学以后决定一直使用四路归并，在空数列时进行移动。

