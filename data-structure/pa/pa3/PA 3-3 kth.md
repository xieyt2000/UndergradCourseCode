# PA 3-3 kth

## 数据结构与算法

本题中使用的数据结构为堆。算法方面，首先对`a, b, c`三个数组内部进行排序，因为无法访问内部元素，所以比较的时候要使用`compare`间接比较，比如`compare(t_cmp1, 1, 1, t_cmp2, 1, 1);`。排序的算法出于效率角度采用了时间空间效率都较高的堆排序。然后维护一个优先级队列（堆），堆中元素为三维向量，对应着在排序完成的`a, b, c`数组中的位置，最小的元素在堆顶。先将`[0, 0, 0]`插入，然后每次弹出后插入三维分别+1的三个向量。为了避免重复，仅当向量在xy平面时插入y+1，仅当向量在x轴时插入x+1，那么取出的第k个弹出的向量在排序好的数组中对应的值即为答案。

## 复杂度分析

空间复杂度方面，要建立三个$O(n)$的数组储存排序结果，堆排序是就地算法，空间复杂度$O(1)$。堆的大小方面，每次弹出一个元素后最多插入三个新元素，因此$O(k)$是一个不紧的上界，本题开的也是$O(k)$大小，然而进一步分析，有$O(n)$个元素（x轴上）会弹出一个插入三个，有$O(n^2)$（x、y平面）个元素会弹出一个插入两个，剩下的均为弹出一个进一个，因此理论上来说最小的空间消耗应为$O(min(k, 2n + n^2))=O(min(k,n^2))$。因此理论空间复杂度为$O(min(k,n^2))$（本程序为$O(k+n))$）。

时间复杂度方面，初始化排序数组$O(n)$，堆排序$O(nlogn)$，利用堆找第k个元素为$O(k)$，因此总体时间复杂度为$O(nlogn+k)$。

## 完成过程中的问题

本题完成过程中遇到的最主要问题就是各个数组间的关系比较复杂。堆中的数据结构`Point`储存的是在`xSortedRank(x=a, b, c)`数组中的位置，而`xSortedRank`储存的是输入数组中对应的位置。另外不能直接访问数组的元素也为比较带来了很大的麻烦。在比较同一个数组中两个元素时，为了效率我写了三个比较函数然后传递函数指针。