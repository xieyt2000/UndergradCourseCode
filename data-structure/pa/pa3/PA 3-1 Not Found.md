# PA 3-1 Not Found

## 数据结构与算法

本题中使用的数据结构为bitmap。算法为先依据输入建立一个24位（结果的最长长度，转为整数为$2^{24}=16777216$ ）的bitmap存储所有连续的24位字符串，然后开始向下循环枚举，每次建立一个新的bitmap，对应的位数-1，并且利用前一个bitmap中的所有数据更新新的bitmap，直到发现一个每一位都被`set`的bitmap，那么其前一个bitmap中的最小值即为输出。关于怎么得到输出最长长度，一个长度为$k$的0/1串有$2^k$种，那么不难得知输出的最长长度严格小于$[log_2 n]$。 

## 复杂度分析

设输入长度为$n$。空间复杂度方面，维护两个bitmap，每个bitmap的空间最大为$O(2^{log_2n})=O(n)$，总体空间复杂度为$O(n)$，使用bitmap的数据结构并没有从渐进意义上优化空间复杂度，但是常数较小。时间复杂度方面，进行$O(logn)$次循环，每次循环复杂度为$O(2^{logi})=O(i)，i$表示第几次循环（从低位开始），那么总体时间复杂度为$O(nlogn)$。

## 完成过程中的问题

本题我一开始就决定该算法，完成过程中主要的改动为刚开始我打算存储输入字符串为一个二进制数，然后我咨询小助教以后明白了没有必要存储输入，直接利用输入更新第一个24位的bitmap即可保留所有我们需要的信息，改进了算法。