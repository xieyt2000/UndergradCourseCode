# PA 2-2 Circuit

## 数据结构与算法

本题中使用的数据结构为字典树，使用数组存储其节点。每个内部节点存储其左右儿子以及有效标记，左表示该位为0，右表示为1每个叶子节点存储其对应的数字序号，存储对应数字号的结构是用链表实现的游标，所有的叶子节点共享一个数组，内部存储链表的头和尾。每个电路的存储使用的方法是将其看作二进制数用`unsigned long long`。算法方面，边输入边查找、删除，需要使用原数据时将`unsigned long long`转成`bool[]`。插入是普通的字典树操作，查找时用高位贪心的方法找到最佳的有效叶子，因为要求输出序号最小的项，直接返回叶子节点对应链表的第一项即可。删除操作时，先通过原始数据找到树中路径，再从下往上检查，如果该点的儿子中无有效数据则将该点标记为无效。

## 复杂度分析

空间复杂度方面，维护一个高度为64的树，最多$N$ 个叶子，即有$O(64N)$个节点，链表数组、原始数据均为$O(N)$，总体复杂度$O(N)$ ，但是常数较大，内存很紧张。时间复杂度方面，总共有$O(N+K)$​个循环，插入、删除、查找操作涉及的节点均在一条路径上，复杂度$O(64)$，总体复杂度$O(N+K)$，然而常数也是很大。

## 完成过程中的问题

本题我一开始就确定了使用字典树，但是算法实现上有很多变化。起初我采用了指针存储树，用`new`、`delete`管理节点，然而时间消耗太大。于是我被迫放弃了oop上养成的良好习惯，全都使用数组存储。开始节点中除存储现有量外还有父亲，，然后内存不足，于是我只得放弃存储父亲，删除时先通过原始数据找一遍路径。然而内存还是不足，原因在于并且用`bool[]`存储数据，只得改为`unsigned long long`存储数据，使用时转换为`bool[]`。
